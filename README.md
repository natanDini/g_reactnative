# Class Components vs Function Components

| Aspecto                   | Class Components                                  | Functional Components                                       |
|---------------------------|---------------------------------------------------|-------------------------------------------------------------|
| **Sintaxe**               | Usa sintaxe de classe (ES6)                       | Usa sintaxe de função (ES6)                                 |
| **Estado**                | `this.state` e `setState`                         | `useState()` e outros *Hooks*                               |
| **Ciclo de Vida**         | Métodos como `componentDidMount`, `componentDidUpdate`, etc. | `useEffect()` (combina diferentes estágios do ciclo de vida) |
| **Reutilização de Lógica**| Geralmente mais complexa (HOCs, Render Props)     | Simples, via *Custom Hooks*                                 |
| **Performance**           | Equivalente; pode usar `PureComponent`            | Equivalente; pode usar `React.memo`, `useMemo`, `useCallback` |
| **Legibilidade**          | Mais verboso, precisa lidar com `this`            | Geralmente mais limpo e conciso                             |
| **Uso atual**             | Principalmente em código legado ou preferências   | É o padrão recomendado e mais utilizado atualmente          |

# Hooks

| **Hook**         | **Descrição / Quando Usar**                                                                                                                                                                                                                                                                                                                     | **Exemplo (simplificado)**                                                                                                                                                          | **Observações**                                                                                                                                                                                                                                                                                                                                                                                      |
|------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **useState**     | Gerencia estado local em componentes funcionais. Útil para qualquer informação que precise mudar ao longo do tempo (e causar re-render).                                                                                                                                                                                                         | ```jsx<br/>const [count, setCount] = useState(0);<br/><br/>return (<br/>  <Button<br/>    title="Incrementar"<br/>    onPress={() => setCount(count + 1)}<br/>  />);<br/>```       | - Substitui a necessidade de `this.state` em componentes de classe.<br/>- Ao chamar `setCount`, o componente re-renderiza com o novo valor.<br/>- Cada chamada de Hook cria um "estado independente".                                                                                                                                                                                                   |
| **useEffect**    | Permite lidar com efeitos colaterais (requisições HTTP, assinaturas de eventos, timers, etc.). Substitui métodos de ciclo de vida (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).                                                                                                                                           | ```jsx<br/>useEffect(() => {<br/>  // Efeito (ex.: buscar API)<br/>  return () => {<br/>    // Cleanup (ex.: limpar intervalos)<br/>  };<br/>}, [dependencias]);<br/>```           | - Se chamar sem array de dependências, roda a cada render.<br/>- Com array vazio `[]`, roda apenas no `mount` do componente.<br/>- O retorno (função) é executado na desmontagem ou antes de recriar o efeito.<br/>- Em React Native, use para interagir com APIs nativas, sensoriais, etc.                                                                                                                |
| **useContext**   | Consome valores de um contexto React sem precisar de Consumers em JSX. Ideal para compartilhar dados “globais” (tema, idioma, usuário autenticado) entre diversos componentes, sem “prop drilling”.                                                                                                                                             | ```jsx<br/>const tema = useContext(ThemeContext);<br/>return <Text>{tema}</Text>;<br/>```                                                                                           | - Substitui `contextType` ou `<Context.Consumer>` em componentes de classe.<br/>- Útil quando combinado com `Context.Provider` em um componente de nível mais alto para toda a aplicação ou parte dela.<br/>- Evite abusar de Context para tudo (pode afetar performance se for muito amplo).                                                                                                          |
| **useRef**       | Armazena uma referência mutável que não causa re-render ao mudar. Usado para manipular elementos diretamente ou guardar valores que persistem entre renderizações sem atualizar a UI.                                                                                                                                                           | ```jsx<br/>const inputRef = useRef(null);<br/><br/>useEffect(() => {<br/>  inputRef.current?.focus();<br/>}, []);<br/>```                                                                                                 | - Ao contrário do `useState`, alterar `ref.current` **não** dispara re-render.<br/>- Comum para focar inputs, rolar `ScrollView`, armazenar qualquer valor mutável (ex.: contador, ID de intervalo).<br/>- Em RN, substitui a necessidade de usar “componentes controlados” ou `createRef` de classes para certas necessidades.                                                                                |
| **useMemo**      | Memoiza (armazena em cache) o resultado de uma função que faz cálculo pesado. Recalcula somente quando as dependências mudam. Útil para evitar recomputar valores custosos a cada render.                                                                                                                                                        | ```jsx<br/>const valorMemoizado = useMemo(() => {<br/>  // Cálculo pesado<br/>  return resultado;<br/>}, [dependencias]);<br/>```                                                                                        | - Ajuda na performance quando há operações custosas (por ex.: loops longos).<br/>- Não use para “tudo”, apenas quando realmente existir um gargalo de cálculo ou renderização.<br/>- Similar a `PureComponent` em classes, mas mais granular.                                                                                                                                                              |
| **useCallback**  | Memoiza a **função** em si, evitando que ela seja recriada a cada render e disparando re-renderizações em componentes filhos que recebem essa função como prop.                                                                                                                                                                                 | ```jsx<br/>const handleClick = useCallback(() => {<br/>  // Lógica<br/>}, [dependencias]);<br/>```                                                                                 | - Similar ao `useMemo`, mas específico para funções.<br/>- Útil quando você passa callbacks para componentes filhos que usam `React.memo` e não quer que eles re-renderizem desnecessariamente.<br/>- Exige cuidado: usar demasiadamente pode complicar o código.                                                                                                                                         |
| **Custom Hooks** | Hooks criados pelo próprio desenvolvedor, permitindo extrair e reutilizar lógica de estado/efeitos em vários componentes.                                                                                                                                                                                                                       | ```jsx<br/>function useContador() {<br/>  const [count, setCount] = useState(0);<br/>  function inc() { setCount(c => c + 1); }<br/>  return { count, inc };<br/>}<br/><br/>export default useContador;<br/>```         | - Naming convention: sempre comece com “use” (ex.: `useContador`, `useAuth`).<br/>- Pode envolver outros Hooks (`useEffect`, `useState` etc.) e lógica de negócio.<br/>- Facilita separar responsabilidades e reaproveitar código.                                                                                                                                                                      |

# Web Vitals

| **Tópico**                           | **O que é**                                                                                                                                                    | **Aplicação no React Native**                                                                                                                                                                                                                                      | **Observações**                                                                                                                                                                                                                                                                                |
|--------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Web Vitals (LCP, FID, CLS)**       | Conjunto de métricas de performance definido pelo Google para medir experiência do usuário em páginas web (tempo de carregamento, interatividade, layout). | Não se aplicam diretamente, pois React Native não roda em navegador, mas sim em ambiente nativo (Android/iOS). A renderização é feita via componentes nativos, não DOM/HTML.                                                                                       | - Focadas em páginas web rodando em navegadores.<br/>- LCP (Largest Contentful Paint), FID (First Input Delay) e CLS (Cumulative Layout Shift) são métricas específicas do fluxo de carregamento HTML/CSS.<br/>- Não fazem sentido para Apps nativos.                                          |
| **Por que não se aplicam ao RN**     | São métricas de **páginas web** (HTML, CSS, JS) rodando em navegadores e mensuradas por ferramentas como Lighthouse, PageSpeed e `web-vitals`.               | Em React Native, o app é construído sobre “bridges” para componentes nativos, sem DOM. Todo o ciclo de render e layout é diferente, e o conceito de “page load” não existe do mesmo modo que na web.                                                                | - Ambiente de execução distinto (nativo vs. navegador).<br/>- Layout e fluxo de renderização não usam a árvore DOM.<br/>- Métricas como LCP e CLS não têm correlação direta com UI nativa.                                                                                                                                          |
| **Métricas de Performance em RN**    | Focam em **startup time**, **FPS (frames por segundo)**, **interatividade** e **consumo de recursos** (CPU, memória).                                                                               | Medir tempo de inicialização do app, fluidez em animações/transições, responsividade ao toque, estabilidade de layout (evitar “saltos” visuais), etc.                                                                                                              | - Usar Ferramentas nativas (Xcode Instruments, Android Studio Profiler) para medir CPU, memória, GPU.<br/>- Analisar “time to first interaction” (TTFI) e “time to usable UI”.                                                                                                                                                    |
| **Ferramentas de Monitoramento**     | Na web, usamos `web-vitals` ou Lighthouse. Em RN, utilizamos **Flipper**, **React DevTools Profiler**, **Sentry (Performance)**, **Firebase Performance**, etc. | Ferramentas específicas do ecossistema nativo para inspecionar logs, uso de rede, profiling de CPU e memória, medir renders de componentes, etc.                                                                                                                   | - **Flipper**: App oficial de debug e performance do RN.<br/>- **React DevTools Profiler**: Análise de re-renderização, árvore de componentes.<br/>- **Xcode / Android Studio**: análise de recursos de hardware.<br/>- **Sentry** / **Crashlytics** com recursos de monitoramento de performance.                                  |
| **Conclusão**                        | Web Vitals são direcionados a experiências em navegadores. Para React Native, há métricas e ferramentas próprias, focadas em fluxo de apps nativos.         | Concentre-se em mensurar **UX nativa**: tempo de inicialização, fluidez de animações, responsividade ao toque, consumo de memória/CPU, etc.                                                                                                                         | - RN tem ambiente diferenciado e requer estratégias de medição adequadas.<br/>- Se você precisa de métricas de “mobile vitals”, use APIs de performance e logs de execução nativos.<br/>- Objetivo: garantir uma experiência fluida e responsiva no contexto de apps móveis.                                                   |
